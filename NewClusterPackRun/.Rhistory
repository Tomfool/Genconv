if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = 0.7;}
while(step++ < steps){
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));}
Rcpp::NumericVector dL = dlnL(XX( _, step - 1), Ycpp, Xcpp);
return wrap(dL);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 100;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = 0.7;}
//while(step++ < steps){
//Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
//XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));}
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Ycpp, Xcpp));
return wrap(dL);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
dlnL_brute_cpp(beta, Y, X)
dlnL_brute_cpp(c(0.7, 0.7), Y, X)
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 100;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = 0.7;}
while(step++ < steps){
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
//XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));}
return wrap(dL);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 100;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = 0.7;}
while(step++ < steps){
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
}
//XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));}
return wrap(dL);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 100;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = 0.7;}
while(step++ < steps){
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
//XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));
}
return wrap(step);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 100;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = 0.7;}
while(step++ < steps){
i++;
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
//XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));
}
return wrap(i);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 100;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = 0.7;}
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
while(step++ < steps){
dL = dlnL(XX( _, step - 1), Y, X);
//XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));
}
return wrap(dL);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
dlnL_brute_cpp(c(0.7,0.7), Y, X)
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 100;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = i;}
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
while(step++ < steps){
dL = dlnL(XX( _, step - 1), Y, X);
//XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));
}
return wrap(dL);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 100;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = 0.7;}
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
while(step++ < steps){
dL = dlnL(XX( _, step - 1), Y, X);
XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));
}
return wrap(dL);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 100;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = i;}
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
while(step++ < steps){
dL = dlnL(XX( _, step - 1), Y, X);
XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));
}
return wrap(dL);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 100;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = i;}
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
while(step++ < steps){
dL = dlnL(XX( _, step - 1), Y, X);
//XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));
}
return wrap(dL);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
dlnL_brute_cpp(c(198, 199), Y, X)
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 100;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = i;}
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
while(step++ < steps){
dL = dlnL(XX( _, step - 1), Y, X);
XX(_, step) = XX(_, step - 1) + stepsize1 * dL;// + stepsize2*(XX(_, step - 1) - XX(_, step - 2));
}
return wrap(dL);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 100;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = i;}
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
while(step++ < steps - 1){
dL = dlnL(XX( _, step - 1), Y, X);
XX(_, step) = XX(_, step - 1) + stepsize1 * dL;// + stepsize2*(XX(_, step - 1) - XX(_, step - 2));
}
return wrap(dL);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
glm(Y~X, family = binomial)$coef
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 100;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = i;}
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
while(step++ < steps - 1){
dL = dlnL(XX( _, step - 1), Y, X);
XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));
}
return wrap(XX);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
glm(Y~X, family = binomial)$coef
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 1000;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = i;}
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
while(step++ < steps - 1){
dL = dlnL(XX( _, step - 1), Y, X);
XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));
}
return wrap(XX);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
glm(Y~X, family = binomial)$coef
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 1000;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = i;}
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
while(step < steps ){
dL = dlnL(XX( _, step - 1), Y, X);
XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));
step ++
}
return wrap(XX);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 1000;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = i;}
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
while(step < steps ){
dL = dlnL(XX( _, step - 1), Y, X);
XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));
step ++;
}
return wrap(XX);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
glm(Y~X, family = binomial)$coef
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 1000;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = i;}
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
while(step < steps ){
dL = dlnL(XX( _, step - 1), Y, X);
XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));
step ++;
}
return wrap(XX);
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
glm(Y~X, family = binomial)$coef
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 1000;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 2;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = i;}
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
while(step < steps ){
dL = dlnL(XX( _, step - 1), Y, X);
XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));
step ++;
}
return wrap(XX(_, step - 1));
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
glm(Y~X, family = binomial)$coef
rm(list=ls())  # clean up workspace
source("/Users/xji3/Dropbox/My Files/ST810-Big Data/ST810_HW1[rmd2r].R")
# Cpp code for GD algorithm
GD_optim_code = '
Rcpp::Function dlnL("dlnL_brute_cpp");
Rcpp::NumericVector betacpp(beta); Rcpp::NumericVector Xcpp(X);	int steps = 1000;
Rcpp::NumericVector Ycpp(Y); int n = Xcpp.size();	int m = Ycpp.size();
if (m < n) n = m;	double stepsize1 = 0.05; double stepsize2 = 0.5; int step = 1;
Rcpp::NumericMatrix XX(betacpp.size(), steps);
for (int i = 0; i < XX.nrow() * XX.ncol(); i++) {XX[i] = i;}
Rcpp::NumericVector dL(dlnL(XX( _, step - 1), Y, X));
while(step ++ < steps - 1 ){
dL = dlnL(XX( _, step - 1), Y, X);
XX(_, step) = XX(_, step - 1) + stepsize1 * dL + stepsize2*(XX(_, step - 1) - XX(_, step - 2));
}
return wrap(XX(_, step - 1));
'
test = "
return (stepsize1 * callFunction(XX[_, step - 1], Y, X, dlnL_brute_cpp));
"
optim_GD_momentum <- cxxfunction(signature(beta = "numerc", Y = "numeric", X = "numeric"),
body = GD_optim_code,plugin = "Rcpp")
n <- 1E1; Y <- runif(n); Y <- as.numeric(Y > 0.5)
X <- runif(n, min = 0.2, max = 1.0); beta <- runif(2, min = 0.2, max = 0.8)
optim_GD_momentum(beta, Y, X)
glm(Y~X, family = binomial)$coef
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
Tau.diff.mat[filter,1] / Tau.diff.mat[filter,2]
Tau.diff.mat[filter,1]
Tau.diff.mat[filtered.pairs,1] / Tau.diff.mat[filtered.pairs,2]
hist(Tau.diff.mat[filtered.pairs,1] / Tau.diff.mat[filtered.pairs,2])
table(Tau.diff.mat[filtered.pairs,1] / Tau.diff.mat[filtered.pairs,2])
dist(1:p)
p = 10
dist(1:p)
